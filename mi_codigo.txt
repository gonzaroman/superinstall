------------------------------------------------
ARCHIVO: ./core/config.py
------------------------------------------------


------------------------------------------------
ARCHIVO: ./core/constants.py
------------------------------------------------


------------------------------------------------
ARCHIVO: ./core/managers/base.py
------------------------------------------------
import os
import signal
import subprocess
import re
from abc import ABC, abstractmethod
from utils.signals import Comunicador

class BaseManager(ABC):
    def __init__(self, comunicador: Comunicador):
        self.comunicador = comunicador
        self.proceso_actual = None # <--- Para guardar el proceso

    
    def ejecutar_comando_con_progreso(self, comando, patron_regex):
        try:
            # CORRECCI√ìN: Un solo Popen y lo guardamos en self.proceso_actual
            self.proceso_actual = subprocess.Popen(
                comando,
                shell=True,
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                text=True,
                bufsize=1,
                universal_newlines=True,
                start_new_session=True
            )

            # Leemos l√≠nea a l√≠nea desde self.proceso_actual
            for linea in self.proceso_actual.stdout:
                linea_limpia = linea.strip()
                print(linea_limpia) # Debug
                
                match = re.search(patron_regex, linea_limpia)
                if match:
                    try:
                        valor = int(match.group(1))
                        self.comunicador.progreso_actualizado.emit(valor)
                    except (ValueError, IndexError):
                        pass

            self.proceso_actual.wait()
            return self.proceso_actual.returncode == 0
        
            
        except Exception as e:
            print(f"Error ejecutando comando: {e}")
            return False

    def cancelar_operacion(self):
        if self.proceso_actual:
            try:
                # Usamos SIGKILL (se√±al 9) para forzar el cierre inmediato
                # de pkexec y todos sus hijos (apt, dpkg, etc.)
                os.killpg(os.getpgid(self.proceso_actual.pid), signal.SIGKILL)
                print(">>> Proceso ELIMINADO forzosamente por el usuario.")
            except ProcessLookupError:
                pass 
            except Exception as e:
                print(f"Error al cancelar: {e}")
            finally:
                self.proceso_actual = None
                
    def obtener_tamano_archivo(self, ruta_archivo):
        """Devuelve el tama√±o del archivo en formato legible (MB/KB)."""
        try:
            bytes_size = os.path.getsize(ruta_archivo)
            if bytes_size < 1024 * 1024:
                return f"{bytes_size / 1024:.1f} KB"
            return f"{bytes_size / (1024 * 1024):.1f} MB"
        except:
            return "Tama√±o desconocido"

    # --- M√âTODOS ABSTRACTOS (A implementar por cada hijo) ---
    @abstractmethod
    def obtener_datos(self, ruta_archivo): pass

    @abstractmethod
    def buscar_icono(self, ruta_archivo): pass

    @abstractmethod
    def instalar(self, ruta_archivo): pass

    @abstractmethod
    def desinstalar(self, identificador): pass

    @abstractmethod
    def esta_instalado(self, ruta_archivo): pass

------------------------------------------------
ARCHIVO: ./core/managers/deb.py
------------------------------------------------
import os
import subprocess
from .base import BaseManager

class DebManager(BaseManager):
    def obtener_datos(self, ruta_archivo):
        """Extrae el nombre, versi√≥n y peso del archivo .deb."""
        try:
            # 1. Extraemos versi√≥n y nombre interno del paquete
            cmd = f"dpkg-deb -f '{ruta_archivo}' Package Version"
            salida = subprocess.check_output(cmd, shell=True, text=True)
            datos = {l.split(': ')[0]: l.split(': ')[1].strip() for l in salida.strip().split('\n') if ': ' in l}
            
            nombre = datos.get('Package', 'App')
            version = datos.get('Version', '0.0')
            
            # 2. Obtenemos el peso usando el m√©todo de la clase padre
            peso = self.obtener_tamano_archivo(ruta_archivo)
            
            # 3. Formateamos la descripci√≥n final
            # Ejemplo: "APP Debian ‚Ä¢ v0.0.28 ‚Ä¢ 85.2 MB ‚Ä¢ lista para instalar"
            info_texto = f"APP Debian ‚Ä¢ v{version} ‚Ä¢ {peso} ‚Ä¢ lista para instalar"
            
            return nombre.capitalize(), info_texto
            
        except Exception as e:
            # Fallback en caso de que el archivo est√© corrupto o dpkg falle
            peso_error = self.obtener_tamano_archivo(ruta_archivo)
            return "Archivo Debian", f"Error al leer metadatos ‚Ä¢ {peso_error}"

    def buscar_icono(self, ruta_deb):
        """Extrae el icono del paquete .deb."""
        ruta_temp = "/tmp/instalador_icono_deb"
        if not os.path.exists(ruta_temp):
            os.makedirs(ruta_temp)
            
        try:
            # Intento 1: Buscar iconos de alta resoluci√≥n
            cmd = f"dpkg-deb -c '{ruta_deb}' | grep -E '256|128|scalable' | grep -E '.png|.svg' | head -n 1"
            linea = subprocess.getoutput(cmd)
            
            # Intento 2: Si falla, buscar cualquier cosa que parezca un icono
            if not linea:
                cmd = f"dpkg-deb -c '{ruta_deb}' | grep -E '.png|.svg' | grep -E 'icon|logo' | head -n 1"
                linea = subprocess.getoutput(cmd)
            
            if linea:
                ruta_en_deb = linea.split()[-1].lstrip('.')
                ruta_final_icono = f"{ruta_temp}/icon.png"
                # Extraer el archivo espec√≠fico del tar del deb
                subprocess.run(f"dpkg-deb --fsys-tarfile '{ruta_deb}' | tar -xOf - '.{ruta_en_deb}' > {ruta_final_icono}", shell=True, timeout=5)
                self.comunicador.icono_listo.emit(ruta_final_icono)
        except Exception as e:
            print(f"Error extrayendo icono DEB: {e}")

    def instalar(self, ruta_archivo):
        """
        Instala un archivo .deb usando apt-get para resolver dependencias 
        y captura el progreso real de la instalaci√≥n.
        """
        # 1. Usamos apt-get en lugar de dpkg porque apt-get descarga dependencias faltantes.
        # El par√°metro -o Dpkg::Progress-Fancy=1 fuerza a APT a mostrar la barra de progreso.
        comando = f"pkexec apt-get install -y -o Dpkg::Progress-Fancy=1 {ruta_archivo}"
        
        # 2. El patr√≥n para APT es un poco distinto. 
        # Suele mostrar: "Progress: [ 25%]"
        patron_deb = r"Progress: \[ *(\d+)%\]"
        
        # 3. Ejecutamos usando la maquinaria del padre (BaseManager)
        exito = self.ejecutar_comando_con_progreso(comando, patron_deb)
        
        # 4. Resultado a la UI
        if exito:
            self.comunicador.instalacion_completada.emit(True, "install_success")
        else:
            self.comunicador.instalacion_completada.emit(False, "install_error")

    def desinstalar(self, ruta_desktop):
        """Identifica el paquete a trav√©s del archivo .desktop y lo elimina."""
        try:
            # Tu l√≥gica para encontrar qu√© paquete instal√≥ ese archivo .desktop
            res = subprocess.getoutput(f"dpkg -S '{ruta_desktop}'")
            if ":" in res:
                pkg = res.split(":")[0]
                # Eliminaci√≥n silenciosa
                subprocess.run(f"pkexec apt-get remove -y {pkg}", shell=True)
                return True
        except:
            # Si falla dpkg, intentamos borrar el acceso directo al menos
            subprocess.run(f"pkexec rm '{ruta_desktop}'", shell=True)
        return False
    
    def esta_instalado(self, ruta_archivo):
        nombre_pkg, _ = self.obtener_datos(ruta_archivo)
        # Ejecutamos dpkg -s para ver si el paquete est√° instalado
        res = subprocess.run(["dpkg", "-s", nombre_pkg], capture_output=True)
        return res.returncode == 0

------------------------------------------------
ARCHIVO: ./core/managers/appimage.py
------------------------------------------------
import os
import shutil
import subprocess
from .base import BaseManager

class AppImageManager(BaseManager):
    def __init__(self, comunicador):
        super().__init__(comunicador)
        self.ruta_icono_extraido = ""  # Aqu√≠ guardaremos la ruta para el .desktop

    def obtener_datos(self, ruta_archivo):
        """Extrae el nombre del archivo y a√±ade el peso detectado."""
        
        nombre = os.path.basename(ruta_archivo).replace(".AppImage", "").split("-")[0]
        
        
        peso = self.obtener_tamano_archivo(ruta_archivo)
        
        
        # Ejemplo: "AppImage ‚Ä¢ 124.5 MB ‚Ä¢ listo para usar"
        info_texto = f"AppImage ‚Ä¢ {peso} ‚Ä¢ listo para usar"
        
        return nombre.capitalize(), info_texto 
    
    def buscar_icono(self, ruta_appimage):
        """Tu l√≥gica original exacta de extracci√≥n de iconos"""
        ruta_temp = "/tmp/superinstall_appdir"
        if os.path.exists(ruta_temp):
            try: shutil.rmtree(ruta_temp)
            except: pass
        os.makedirs(ruta_temp, exist_ok=True)
        
        try:
            os.chmod(ruta_appimage, 0o755)
            comandos_rapidos = [
                [ruta_appimage, "--appimage-extract", ".DirIcon"],
                [ruta_appimage, "--appimage-extract", "*.png"],
                [ruta_appimage, "--appimage-extract", "*.svg"],
            ]
            icono_encontrado = False
            root_extract = os.path.join(ruta_temp, "squashfs-root")
            
            for cmd in comandos_rapidos:
                if icono_encontrado: break
                try:
                    subprocess.run(cmd, cwd=ruta_temp, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, timeout=5)
                    if os.path.exists(root_extract):
                        icono = self._buscar_mejor_icono_rapido_ORIGINAL(root_extract)
                        if icono:
                            icono_encontrado = True
                            break
                except: continue
            
            if not icono_encontrado:
                try:
                    subprocess.run([ruta_appimage, "--appimage-extract"], cwd=ruta_temp, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, timeout=15)
                except: return
            
            if not os.path.exists(root_extract): return
            
            icono = self._buscar_mejor_icono_rapido_ORIGINAL(root_extract)
            if icono:
                ext = os.path.splitext(icono)[1]
                ruta_preview = f"/tmp/appimage_last_icon{ext}"
                shutil.copy2(icono, ruta_preview)
                self.ruta_icono_extraido = ruta_preview # Guardamos para instalar()
                self.comunicador.icono_listo.emit(ruta_preview) # Enviamos a la GUI
        except: pass

    def _buscar_mejor_icono_rapido_ORIGINAL(self, root_extract):
        """Tu funci√≥n original de b√∫squeda con os.walk"""
        rutas_prioritarias = [".DirIcon", "usr/share/icons/hicolor/256x256/apps", "usr/share/icons/hicolor/scalable/apps", "usr/share/pixmaps", "."]
        for ruta_rel in rutas_prioritarias:
            ruta_busqueda = os.path.join(root_extract, ruta_rel)
            if not os.path.exists(ruta_busqueda): continue
            try:
                if os.path.isfile(ruta_busqueda): archivos = [ruta_busqueda]
                else: archivos = [os.path.join(ruta_busqueda, f) for f in os.listdir(ruta_busqueda) if f.lower().endswith(('.png', '.svg'))]
                for archivo in archivos:
                    nombre = os.path.basename(archivo).lower()
                    if any(x in nombre for x in [".diricon", "icon", "logo"]) and archivo.endswith('.png'):
                        if os.path.getsize(archivo) > 1000: return archivo
            except: continue
        
        candidatos = []
        for root, dirs, files in os.walk(root_extract):
            nivel = root.replace(root_extract, '').count(os.sep)
            if nivel > 2:
                dirs[:] = []
                continue
            for f in files:
                if f.lower().endswith(('.png', '.svg')):
                    ruta_full = os.path.join(root, f)
                    try:
                        tam = os.path.getsize(ruta_full)
                        if tam > 1000: candidatos.append((tam, ruta_full))
                        if len(candidatos) >= 10: break
                    except: continue
            if len(candidatos) >= 10: break
        
        if candidatos:
            candidatos.sort(reverse=True)
            return candidatos[0][1]
        return None

    def instalar(self, ruta_archivo):
        """Usa la ruta_icono_extraido que encontr√≥ buscar_icono"""
        dest_bin = os.path.expanduser("~/Applications")
        dest_apps = os.path.expanduser("~/.local/share/applications")
        dest_icons = os.path.expanduser("~/.local/share/icons")
        for d in [dest_bin, dest_apps, dest_icons]: os.makedirs(d, exist_ok=True)
        
        nombre_app = os.path.basename(ruta_archivo).replace(".AppImage", "").split("-")[0].capitalize()
        nombre_limpio = nombre_app.lower().replace(" ", "_")
        ruta_ejecutable = os.path.join(dest_bin, os.path.basename(ruta_archivo))
        
        try:
            shutil.copy2(ruta_archivo, ruta_ejecutable)
            os.chmod(ruta_ejecutable, 0o755)
            
            ruta_icon_final = "system-run"
            if self.ruta_icono_extraido:
                ruta_icon_final = os.path.join(dest_icons, f"{nombre_limpio}{os.path.splitext(self.ruta_icono_extraido)[1]}")
                shutil.copy2(self.ruta_icono_extraido, ruta_icon_final)
            
            with open(os.path.join(dest_apps, f"{nombre_limpio}.desktop"), "w") as f:
                f.write(f"[Desktop Entry]\nType=Application\nName={nombre_app}\nExec=\"{ruta_ejecutable}\"\nIcon={ruta_icon_final}\nTerminal=false\nCategories=Utility;\n")
            
            self.comunicador.instalacion_completada.emit(True, "install_success")
        except Exception as e:
            self.comunicador.instalacion_completada.emit(False, "install_error")

    def desinstalar(self, ruta_desktop):
        """Tu l√≥gica original de borrado de archivos de usuario"""
        try:
            rb, ri = "", ""
            with open(ruta_desktop, 'r') as f:
                c = f.read()
                for l in c.split('\n'):
                    if l.startswith("Exec="): rb = l.split('=')[1].strip('"').split()[0]
                    if l.startswith("Icon="): ri = l.split('=')[1]
            if os.path.exists(rb) and "Applications" in rb: os.remove(rb)
            if os.path.exists(ri) and ".local" in ri: os.remove(ri)
            if os.path.exists(ruta_desktop): os.remove(ruta_desktop)
            return True
        except: return False
    
    def esta_instalado(self, ruta_archivo):
        dest_bin = os.path.expanduser("~/Applications")
        ruta_ejecutable = os.path.join(dest_bin, os.path.basename(ruta_archivo))
        return os.path.exists(ruta_ejecutable)

------------------------------------------------
ARCHIVO: ./core/managers/flatpak.py
------------------------------------------------
import subprocess
import os
import re
from .base import BaseManager

class FlatpakManager(BaseManager):
    def __init__(self, comunicador, lang):
        super().__init__(comunicador)
        self.lang = lang # Recibimos las traducciones desde la App principal

    def obtener_datos(self, ruta_archivo):
        """Extrae el nombre legible y el peso, usando traducciones."""
        base = os.path.basename(ruta_archivo).replace(".flatpakref", "").replace(".flatpak", "")
        partes = base.split('.')
        
        if len(partes) > 1:
            nombre = partes[-1]
            if nombre.lower() in ["app", "desktop", "auth"] and len(partes) > 2:
                nombre = partes[-2]
        else:
            nombre = partes[0]
        
        peso = self.obtener_tamano_archivo(ruta_archivo)
        
        # TRADUCCIONES: Usamos llaves del JSON
        txt_tipo = self.lang.get("type_flatpak", "Flatpak App")
        txt_estado = self.lang.get("ready_to_install", "ready to install")

        return nombre.capitalize(), f"{txt_tipo} ‚Ä¢ {peso} ‚Ä¢ {txt_estado}"

    def obtener_id_desde_archivo(self, ruta_archivo):
        """Extrae el ID real (io.github.X) de .flatpakref o binarios .flatpak."""
        if ruta_archivo.endswith(".flatpakref"):
            try:
                with open(ruta_archivo, 'r') as f:
                    for linea in f:
                        if linea.startswith(('Application=', 'Name=')):
                            return linea.split('=')[1].strip()
            except: return None
        
        elif ruta_archivo.endswith(".flatpak"):
            try:
                res = subprocess.run(
                    ["flatpak", "info", "--show-metadata", ruta_archivo], 
                    capture_output=True, text=True
                )
                for linea in res.stdout.split('\n'):
                    if linea.startswith('name='):
                        return linea.split('=')[1].strip()
            except: return None
        return None

    def esta_instalado(self, ruta_archivo):
        """Detecta si la app ya existe en el sistema."""
        app_id = self.obtener_id_desde_archivo(ruta_archivo)
        if not app_id:
            app_id = os.path.basename(ruta_archivo).split('.')[0]
        
        try:
            res = subprocess.run(["flatpak", "info", "--system", app_id], capture_output=True)
            return res.returncode == 0
        except: return False

    def instalar(self, ruta_archivo):
        """Instala el paquete capturando el progreso real."""
        comando = f"pkexec flatpak install --system -y --noninteractive --or-update {ruta_archivo}"
        patron_progreso = r"(\d+)%"
        
        exito = self.ejecutar_comando_con_progreso(comando, patron_progreso)
        
        # Si falla pero ya existe, lo damos por bueno
        if not exito and self.esta_instalado(ruta_archivo):
            exito = True 

        # Enviamos la LLAVE del mensaje, no el texto
        self.comunicador.instalacion_completada.emit(exito, "install_success" if exito else "install_error")

    def listar_instalados(self):
        """Lista apps instaladas y busca sus iconos de forma inteligente."""
        apps = []
        bases = [
            os.path.expanduser("~/.local/share/flatpak/exports/share/icons/hicolor"),
            "/var/lib/flatpak/exports/share/icons/hicolor"
        ]
        tamanos = ["scalable/apps", "128x128/apps", "64x64/apps", "48x48/apps", "32x32/apps"]

        try:
            res = subprocess.run(
                ["flatpak", "list", "--app", "--columns=name,application"], 
                capture_output=True, text=True
            )
            if res.returncode == 0:
                for line in res.stdout.strip().split('\n'):
                    parts = line.split('\t')
                    if len(parts) >= 2:
                        app_id = parts[1]
                        ruta_icono = self._buscar_icono_sistema(app_id, bases, tamanos)
                        
                        apps.append({
                            "nombre": parts[0], 
                            "id": app_id, 
                            "icono": ruta_icono
                        })
        except Exception as e:
            print(f"Error listing Flatpaks: {e}")
        return apps

    def _buscar_icono_sistema(self, app_id, bases, tamanos):
        """M√©todo privado para no repetir la l√≥gica del buscador de iconos."""
        for base in bases:
            for tam in tamanos:
                carpeta = os.path.join(base, tam)
                if not os.path.exists(carpeta): continue
                for ext in [".png", ".svg"]:
                    posible = os.path.join(carpeta, f"{app_id}{ext}")
                    if os.path.exists(posible):
                        return posible
        return "preferences-desktop-apps"

    def desinstalar(self, app_id):
        """Desinstala la aplicaci√≥n del sistema."""
        try:
            comando = ["flatpak", "uninstall", "-y", "--noninteractive", app_id]
            res = subprocess.run(comando, capture_output=True, text=True)
            return res.returncode == 0
        except:
            return False

------------------------------------------------
ARCHIVO: ./core/managers/snap.py
------------------------------------------------
import subprocess
import os
import threading
from .base import BaseManager

class SnapManager(BaseManager):
    def __init__(self, comunicador):
        super().__init__(comunicador)

    def obtener_datos(self, ruta_archivo):
        """Extrae el nombre legible y el peso del paquete Snap."""
        # 1. Tu l√≥gica de limpieza de nombre
        base = os.path.basename(ruta_archivo).replace(".snap", "")
        nombre = base.split('_')[0].split('-')[0]
        
        # 2. Obtenemos el peso desde la clase base
        peso = self.obtener_tamano_archivo(ruta_archivo)
        
        # 3. Formateamos la descripci√≥n
        # Ejemplo: "Paquete Snap ‚Ä¢ 64.0 MB ‚Ä¢ listo para instalar"
        info_texto = f"Paquete Snap ‚Ä¢ {peso} ‚Ä¢ listo para instalar"
        
        return nombre.capitalize(), info_texto

    def buscar_icono(self, ruta_archivo):
        """Para instalaciones nuevas desde archivo, usamos el cohete."""
        self.comunicador.icono_listo.emit("")

    def esta_instalado(self, app_id):
        """Verifica si el snap est√° en la lista de instalados."""
        try:
            res = subprocess.run(["snap", "list", app_id], capture_output=True)
            return res.returncode == 0
        except: return False

    def instalar(self, ruta_archivo):
        """
        Instala un paquete Snap local capturando el progreso en tiempo real.
        """
        # 1. Comando como cadena (string) para que funcione con shell=True en BaseManager
        # Usamos pkexec para la elevaci√≥n de privilegios
        comando = f"pkexec snap install --dangerous {ruta_archivo}"
        
        # 2. Definimos el patr√≥n para buscar el porcentaje (ejemplo: "Mounting snap 15%")
        patron_snap = r"(\d+)%"
        
        # 3. Llamamos al m√©todo del padre que ya tiene toda la l√≥gica de lectura
        # NOTA: No hace falta crear un Thread aqu√≠ porque main_window ya lo lanza en uno
        exito = self.ejecutar_comando_con_progreso(comando, patron_snap)
        
        # 4. Emitimos el resultado final
        if exito:
            self.comunicador.instalacion_completada.emit(True, "install_success")
        else:
            self.comunicador.instalacion_completada.emit(False, "install_error")

    def buscar_icono(self, ruta_archivo):
        """Si es un archivo .snap externo, usamos el logo de Snap."""
        # Puedes descargar un logo de snap y ponerlo en assets/snap_logo.png
        # Por ahora, enviamos vac√≠o para que use el cohete o un icono por defecto
        self.comunicador.icono_listo.emit("")

    def listar_instalados(self):
        apps = []
        ruta_iconos_sistema = "/var/lib/snapd/desktop/icons/"
        
        try:
            res = subprocess.run(["snap", "list"], capture_output=True, text=True)
            if res.returncode == 0:
                lineas = res.stdout.strip().split('\n')[1:]
                for line in lineas:
                    parts = line.split()
                    if not parts: continue
                    snap_id = parts[0]
                    
                    if snap_id in ["core", "core18", "core20", "core22", "bare", "gtk-common-themes", "snapd"]:
                        continue

                    # BUSCADOR DE ICONOS MEJORADO
                    ruta_icono_final = "preferences-desktop-apps"
                    encontrado = False

                    # OPCI√ìN 1: La ruta interna del snap (Suele ser la m√°s fiable)
                    # /snap/nombre-app/current/meta/gui/icon.png
                    posibles_internos = [
                        f"/snap/{snap_id}/current/meta/gui/icon.png",
                        f"/snap/{snap_id}/current/meta/gui/icon.svg"
                    ]
                    for p in posibles_internos:
                        if os.path.exists(p):
                            ruta_icono_final = p
                            encontrado = True
                            break

                    # OPCI√ìN 2: Buscar en la carpeta de iconos de snapd
                    if not encontrado and os.path.exists(ruta_iconos_sistema):
                        for f in os.listdir(ruta_iconos_sistema):
                            if f.startswith(snap_id) and (f.endswith(".png") or f.endswith(".svg")):
                                ruta_icono_final = os.path.join(ruta_iconos_sistema, f)
                                encontrado = True
                                break
                    
                    apps.append({
                        "nombre": snap_id.capitalize(),
                        "id": snap_id,
                        "icono": ruta_icono_final
                    })
        except Exception as e:
            print(f"Error en motor Snap: {e}")
        return apps

    def desinstalar(self, app_id):
        try:
            print(f"Iniciando comando: pkexec snap remove {app_id}")
            # A√±adimos capture_output=True y text=True para leer el error real
            res = subprocess.run(
                ["pkexec", "snap", "remove", app_id], 
                capture_output=True, 
                text=True
            )
            
            if res.returncode == 0:
                print(f"Snap {app_id} eliminado correctamente.")
                return True
            else:
                # Esto nos dir√° en la terminal por qu√© no se borr√≥
                print(f"Error al eliminar Snap: {res.stderr}")
                return False
        except Exception as e:
            print(f"Excepci√≥n en SnapManager: {e}")
            return False

------------------------------------------------
ARCHIVO: ./assets/styles/style.qss
------------------------------------------------
/* ============================================
   TEMA OSCURO PROFESIONAL (Estilo Zorin)
   ============================================ */

/* Fondo Principal */
QMainWindow, QStackedWidget {
    background-color: #242424; /* Gris oscuro de fondo */
    color: #ffffff;
}

/* ============================================
   SIDEBAR (Barra lateral)
   ============================================ */
#sidebar {
    background-color: #1e1e1e; /* Un poco m√°s oscuro que el fondo */
    border-right: 1px solid #333333;
}

#logo_sidebar_text {
    color: #ffffff;
    font-size: 22px;
    font-weight: bold;
    padding-left: 15px;
}

/* Botones de navegaci√≥n */
#btn_nav {
    background-color: transparent;
    color: #999999; /* Texto gris apagado */
    border: none;
    border-radius: 8px;
    padding: 15px 20px;
    text-align: left;
    font-size: 16px;
    font-weight: 500;
    margin: 5px 10px;
}

#btn_nav:hover {
    background-color: #333333; /* Gris al pasar el rat√≥n */
    color: #ffffff;
}

/* El bot√≥n activo se marca en AZUL */
#btn_nav[active="true"] {
    background-color: #2a2a2a;
    color: #ffffff;
    font-weight: bold;
    border-left: 4px solid #3498db; /* L√≠nea azul Zorin a la izquierda */
}

/* ============================================
   VISTA INSTALADOR (Centro)
   ============================================ */

/* Contenedor del Icono */
#contenedor_icono {
    background-color: #2a2a2a;
    border: 2px solid #333333;
    border-radius: 30px;
}

/* Textos */
#label_nombre {
    color: #ffffff;
    font-size: 32px;
    font-weight: bold;
    margin-top: 20px;
}

#label_version {
    color: #bbbbbb;
    font-size: 16px;
}

/* Botones de Acci√≥n (Azules) */
#btn_abrir, #btn_instalar {
    background-color: #3498db;
    color: white;
    border: none;
    border-radius: 10px;
    font-weight: bold;
    font-size: 16px;
    padding: 12px;
}

#btn_abrir:hover, #btn_instalar:hover {
    background-color: #2980b9;
}

/* Bot√≥n Volver (X) */
#btn_volver {
    background-color: transparent;
    color: #777777;
    border: none;
    font-size: 20px;
}
#btn_volver:hover { color: #ffffff; }

/* Barra de Progreso */
#barra_progreso {
    background-color: #333333;
    border-radius: 3px;
    border: none;
}
#barra_progreso::chunk {
    background-color: #3498db;
    border-radius: 3px;
}

/* ============================================
   VISTA GESTOR (Lista)
   ============================================ */
#titulo_gestor {
    color: #ffffff;
    font-size: 28px;
    font-weight: bold;
    margin-bottom: 15px;
}

#barra_busqueda {
    background-color: #2a2a2a;
    border: 1px solid #333333;
    border-radius: 10px;
    padding: 10px 15px;
    color: #ffffff;
    font-size: 16px;
}

#barra_busqueda:focus {
    border: 1px solid #3498db;
}

#scroll_area, #scroll_area QWidget {
    background-color: transparent;
    border: none;
}

/* Tarjetas de Apps */
#widget_app {
    background-color: #2a2a2a;
    border: 1px solid #333333;
    border-radius: 12px;
    padding: 12px;
    margin-bottom: 5px;
}

#widget_app:hover {
    border: 1px solid #3498db;
    background-color: #333333;
}

#lbl_nombre_app {
    color: #ffffff;
    font-size: 16px;
    font-weight: bold;
}

/* Badges de tipo */
#badge_tipo { font-size: 11px; font-weight: bold; padding: 4px 8px; border-radius: 6px; color: white;}
QLabel[class="system"]   { background-color: #27ae60; }
QLabel[class="flatpak"]  { background-color: #3498db; }
QLabel[class="snap"]     { background-color: #e67e22; }
QLabel[class="appimage"] { background-color: #9b59b6; }

/* Bot√≥n Eliminar */
#btn_eliminar_app {
    background-color: rgba(231, 76, 60, 0.1);
    color: #e74c3c;
    border: 1px solid #e74c3c;
    border-radius: 8px;
    font-weight: bold;
    padding: 6px 12px;
}
#btn_eliminar_app:hover { background-color: #e74c3c; color: white; }

/* Efecto cuando el archivo est√° "volando" sobre el programa */
#contenedor_icono[drag_active="true"] {
    border: 2px solid #3498db;
    background-color: rgba(52, 152, 219, 0.1);
}

/* Estilo para las Baldosas de la Sidebar */
QToolButton#btn_nav {
    background-color: transparent;
    color: #888888; /* Gris suave para los no activos */
    border: 5px solid transparent;
    border-radius: 10px; /* Bordes bien redondeados */
    font-size: 16px;
    font-weight: bold;
    background-color: #333333;
    
}

QToolButton#btn_nav:hover {
    background-color: #2d2d2d;
    color: #ffffff;
    border: 1px solid #3498db; 
}

/* El bot√≥n activo se ilumina y destaca */
QToolButton#btn_nav[active="true"] {
    background-color: #333333;
    color: #3498db; /* Azul Zorin para el texto */
    border-left: 6px solid #3498db; 
    border-radius: 0px;
    border-top-right-radius: 10px;
    border-bottom-right-radius: 10px;
    border-top-left-radius: 3px;
    border-bottom-left-radius: 3px;
}

/* Ajuste para que el icono no se vea borroso al agrandarlo */
QToolButton#btn_nav QIcon {
    padding: 5px;
}

------------------------------------------------
ARCHIVO: ./assets/locales/es.json
------------------------------------------------
{
    "window_title": "SuperInstall v1.0",
    "btn_install_nav": "Instalar",
    "btn_manage_nav": "Gestionar",
    "welcome_msg": "Bienvenido",
    "drag_drop_info": "Arrastra un .deb, AppImage, Flatpak o Snap",
    "btn_select": "Seleccionar archivo",
    "btn_install": "Instalar Ahora",
    "title_gestor": "Aplicaciones Instaladas",
    "search_placeholder": "Buscar aplicaci√≥n...",
    "install_success": "¬°Integrado con √©xito!",
    "install_error": "Hubo un fallo en la instalaci√≥n",
    "msg_confirm_delete": "¬øEst√°s seguro de que deseas eliminar",
    "title_delete": "Confirmar eliminaci√≥n",
    "flatpak_info": "APP Flatpak ‚Ä¢ lista para instalar",
    "deb_info": "Paquete Debian ‚Ä¢ Listo para instalar",
    "appimage_info": "AppImage Detectada ‚Ä¢ Listo para integrar",
    "snap_info": "Paquete Snap ‚Ä¢ Listo para instalar"
}

------------------------------------------------
ARCHIVO: ./assets/locales/en.json
------------------------------------------------
{
    "window_title": "SuperInstall v3.0",
    "welcome_msg": "Welcome to SuperInstall",
    "drag_drop_info": "Drag and drop an installer file here",
    "btn_install_nav": "Install",
    "btn_manage_nav": "Manage",
    "btn_select": "Select File",
    "btn_install": "Install Now",
    "btn_reinstall": "Reinstall",
    "btn_cancel": "Cancel Installation",
    "already_installed": "(Already installed)",
    "support_not_detected": "support not detected",
    "system_needs": "Your system needs",
    "btn_activate": "Activate",
    "msg_activating": "Activating support... please wait.",
    "title_gestor": "Installed Applications",
    "search_placeholder": "Search apps...",
    "msg_confirm_delete": "Are you sure you want to delete",
    "title_delete": "Delete Application",
    "install_success": "Installation completed successfully!",
    "install_error": "An error occurred during installation."
}

------------------------------------------------
ARCHIVO: ./main.py
------------------------------------------------
import sys
from PySide6.QtWidgets import QApplication
from gui.main_window import InstaladorPro

def main():
    """Punto de entrada principal de la aplicaci√≥n."""
    # 1. Crear la instancia de la aplicaci√≥n
    app = QApplication(sys.argv)
    
    # 2. Configurar el nombre de la organizaci√≥n y la app (√∫til para el sistema)
    app.setApplicationName("SuperInstall")
    app.setOrganizationName("GonzaRoman")

    # 3. Crear y mostrar la ventana principal
    window = InstaladorPro()
    window.show()

    # 4. Ejecutar el bucle de eventos
    sys.exit(app.exec())

if __name__ == "__main__":
    main()

------------------------------------------------
ARCHIVO: ./utils/signals.py
------------------------------------------------
from PySide6.QtCore import QObject, Signal

class Comunicador(QObject):
    """
    Sistema de mensajer√≠a centralizado. 
    Permite que cualquier Manager env√≠e actualizaciones a la UI.
    """
    icono_listo = Signal(str)            # Ruta del icono extra√≠do
    progreso_actualizado = Signal(int)    # Porcentaje 0-100
    instalacion_completada = Signal(bool, str) # (√âxito, Mensaje)

------------------------------------------------
ARCHIVO: ./utils/system_check.py
------------------------------------------------
import shutil

class SystemChecker:
    @staticmethod
    def esta_instalado(motor):
        # Mapeamos extensiones/nombres a binarios reales de Linux
        binarios = {
            "deb": "dpkg",
            "flatpak": "flatpak",
            "snap": "snap",
            "appimage": "chmod" # AppImage solo necesita permisos, siempre True
        }
        binario = binarios.get(motor.lower())
        return shutil.which(binario) is not None

------------------------------------------------
ARCHIVO: ./utils/helpers.py
------------------------------------------------
import os
import json
import locale

def cargar_traducciones():
    """
    Detecta el idioma del sistema y carga el archivo JSON correspondiente.
    Si el idioma no existe, carga el ingl√©s por defecto.
    """
    # 1. Detectar idioma (ej: 'es_ES', 'en_US')
    idioma_sistema, _ = locale.getdefaultlocale()
    codigo_iso = idioma_sistema.split('_')[0] if idioma_sistema else "en"

    # 2. Definir rutas
    ruta_base = os.path.join("assets", "locales")
    ruta_idioma = os.path.join(ruta_base, f"{codigo_iso}.json")
    ruta_default = os.path.join(ruta_base, "en.json")

    # 3. Cargar el archivo
    archivo_a_cargar = ruta_idioma if os.path.exists(ruta_idioma) else ruta_default
    
    try:
        with open(archivo_a_cargar, "r", encoding="utf-8") as f:
            return json.load(f)
    except Exception as e:
        print(f"Error cargando traducciones: {e}")
        return {}

------------------------------------------------
ARCHIVO: ./gui/widgets.py
------------------------------------------------
import os
from PySide6.QtWidgets import QFrame, QHBoxLayout, QVBoxLayout, QLabel, QPushButton
from PySide6.QtCore import Qt, QSize
from PySide6.QtGui import QPixmap, QIcon

class WidgetAppInstalada(QFrame):
    def __init__(self, nombre, ruta_desktop, icono_ref, callback_borrar, lang, tipo_app):
        super().__init__()
        self.setFixedHeight(75) 
        self.setObjectName("widget_app")
        
        # Layout Principal (Horizontal)
        layout_principal = QHBoxLayout(self)
        layout_principal.setContentsMargins(15, 5, 15, 5)
        layout_principal.setSpacing(15)

        #
        # --- 1. ICONO (Versi√≥n Ultra-Compatible) ---
        self.lbl_icono = QLabel()
        self.lbl_icono.setFixedSize(48, 48) 
        self.lbl_icono.setAlignment(Qt.AlignCenter)

        # --- ESTILO DE "BALDOSA" BLANCA ---
        self.lbl_icono.setStyleSheet("""
            background-color: #f8f9fa; /* Blanco muy suave */
            border-radius: 10px;        /* Bordes redondeados */
            padding: 4px;              /* Espacio para que el icono no toque los bordes */
        """)
        
        pixmap = None
        icono_str = str(icono_ref) if icono_ref else ""

        # A. Intentar como RUTA F√çSICA absoluta
        if os.path.isabs(icono_str) and os.path.exists(icono_str):
            pixmap = QPixmap(icono_str)
        
        # B. Intentar como NOMBRE DE TEMA (Ej: "discord", "spotify")
        if (not pixmap or pixmap.isNull()) and icono_str:
            # Quitamos la extensi√≥n y la ruta por si acaso viene sucio
            nombre_icon_tema = os.path.basename(icono_str).split('.')[0]
            icon_theme = QIcon.fromTheme(nombre_icon_tema)
            
            if not icon_theme.isNull():
                # Pedimos el pixmap al tema del sistema (Zorin/Ubuntu)
                pixmap = icon_theme.pixmap(QSize(44, 44))

        # C. APLICAR O FALLBACK
        if pixmap and not pixmap.isNull():
            self.lbl_icono.setPixmap(pixmap.scaled(44, 44, Qt.KeepAspectRatio, Qt.SmoothTransformation))
        else:
            # Fallback elegante: Si no hay icono, usamos uno gen√©rico del sistema
            icon_fallback = QIcon.fromTheme("application-x-executable")
            if not icon_fallback.isNull():
                self.lbl_icono.setPixmap(icon_fallback.pixmap(44, 44))
            else:
                self.lbl_icono.setText("üì¶")
                self.lbl_icono.setStyleSheet("font-size: 24px;")
        
        layout_principal.addWidget(self.lbl_icono)

        # --- 2. CONTENEDOR DE TEXTO (Nombre arriba, Badge abajo) ---
        layout_texto = QVBoxLayout()
        layout_texto.setSpacing(2)
        layout_texto.setAlignment(Qt.AlignVCenter) # Centra el bloque de texto verticalmente

        self.lbl_nombre = QLabel(nombre) 
        self.lbl_nombre.setObjectName("lbl_nombre_app")
        
        # Limitamos el ancho para que el nombre largo no eche al bot√≥n fuera
        self.lbl_nombre.setMaximumWidth(220) 
        
        self.lbl_badge = QLabel(tipo_app.upper())
        self.lbl_badge.setObjectName("badge_tipo")
        self.lbl_badge.setProperty("class", tipo_app.lower()) 
        self.lbl_badge.setFixedSize(65, 18) # Tama√±o fijo para consistencia
        self.lbl_badge.setAlignment(Qt.AlignCenter)
        
        layout_texto.addWidget(self.lbl_nombre)
        layout_texto.addWidget(self.lbl_badge)
        
        layout_principal.addLayout(layout_texto)
        
        # Este espacio empuja el bot√≥n a la derecha
        layout_principal.addStretch()

        # --- 3. BOT√ìN ELIMINAR ---
        texto_boton = lang.get("btn_delete", "Eliminar")
        btn_eliminar = QPushButton(texto_boton)
        btn_eliminar.setObjectName("btn_eliminar_app")
        btn_eliminar.setFixedSize(80, 32) # Tama√±o fijo para que no baile
        btn_eliminar.setCursor(Qt.PointingHandCursor)
        
        btn_eliminar.clicked.connect(lambda: callback_borrar(nombre, ruta_desktop, tipo_app))
        layout_principal.addWidget(btn_eliminar)

------------------------------------------------
ARCHIVO: ./gui/main_window.py
------------------------------------------------
import os
import threading
import subprocess
from PySide6.QtWidgets import (QMainWindow, QVBoxLayout, QWidget, QLabel, 
                             QPushButton, QFileDialog, QHBoxLayout, 
                             QMessageBox, QProgressBar, QScrollArea, QLineEdit, QStackedWidget, QToolButton)
from PySide6.QtCore import Qt, QTimer, QSize
from PySide6.QtGui import QPixmap, QIcon

from utils.system_check import SystemChecker
from utils.signals import Comunicador
from gui.widgets import WidgetAppInstalada
from core.managers.deb import DebManager
from core.managers.appimage import AppImageManager
from core.managers.flatpak import FlatpakManager
from core.managers.snap import SnapManager
from utils.helpers import cargar_traducciones

class InstaladorPro(QMainWindow):
    def __init__(self):
        super().__init__()
        
        # 1. CARGA DE IDIOMA (Ingl√©s por defecto si no hay JSON del sistema)
        self.lang = cargar_traducciones()
        
        self.setWindowTitle(self.lang.get("window_title", "SuperInstall v3.0"))
        self.resize(950, 650)
        self.setMinimumSize(850, 550)
        self.setAcceptDrops(True)
        self.instalando = False
        
        # 2. MANAGERS (Ahora les pasamos self.lang)
        self.comunicador = Comunicador()
        self.mgr_deb = DebManager(self.comunicador, self.lang)
        self.mgr_appimage = AppImageManager(self.comunicador, self.lang)
        self.mgr_flatpak = FlatpakManager(self.comunicador, self.lang)
        self.mgr_snap = SnapManager(self.comunicador, self.lang)
        
        # 3. SE√ëALES
        self.comunicador.icono_listo.connect(self.actualizar_icono_visual)
        self.comunicador.progreso_actualizado.connect(self.actualizar_progreso)
        self.comunicador.instalacion_completada.connect(self.mostrar_resultado)

        # 4. UI Y ESTADO
        self.setup_ui_base()
        self.cargar_estilos()
        self.ruta_archivo = ""
        self.manager_actual = None

    def setup_ui_base(self):
        """Configura la estructura principal: Sidebar + Contenido"""
        self.central_widget = QWidget()
        self.setCentralWidget(self.central_widget)
        self.layout_principal = QHBoxLayout(self.central_widget)
        self.layout_principal.setContentsMargins(0, 0, 0, 0)
        self.layout_principal.setSpacing(0)

        # --- SIDEBAR ---
        self.sidebar = QWidget()
        self.sidebar.setObjectName("sidebar")
        self.sidebar.setFixedWidth(220)
        ly_sidebar = QVBoxLayout(self.sidebar)
        ly_sidebar.setContentsMargins(15, 50, 15, 20)
        ly_sidebar.setSpacing(25)

        # Bot√≥n Instalar
        self.btn_nav_instalar = QToolButton()
        self.btn_nav_instalar.setText(self.lang.get('btn_install_nav', 'Install'))
        self.btn_nav_instalar.setObjectName("btn_nav")
        self.btn_nav_instalar.setProperty("active", True)
        self.btn_nav_instalar.setToolButtonStyle(Qt.ToolButtonTextUnderIcon)
        self.btn_nav_instalar.setIcon(QIcon("assets/icons/nav_install.png"))
        self.btn_nav_instalar.setIconSize(QSize(120, 120))
        self.btn_nav_instalar.setFixedSize(180, 190)
        self.btn_nav_instalar.setCursor(Qt.PointingHandCursor)
        self.btn_nav_instalar.clicked.connect(lambda: self.cambiar_vista(0))

        # Bot√≥n Gestionar
        self.btn_nav_gestionar = QToolButton()
        self.btn_nav_gestionar.setText(self.lang.get('btn_manage_nav', 'Manage'))
        self.btn_nav_gestionar.setObjectName("btn_nav")
        self.btn_nav_gestionar.setToolButtonStyle(Qt.ToolButtonTextUnderIcon)
        self.btn_nav_gestionar.setIcon(QIcon("assets/icons/nav_manage.png"))
        self.btn_nav_gestionar.setIconSize(QSize(120, 120)) 
        self.btn_nav_gestionar.setFixedSize(180, 190)
        self.btn_nav_gestionar.setCursor(Qt.PointingHandCursor)
        self.btn_nav_gestionar.clicked.connect(lambda: self.cambiar_vista(1))

        ly_sidebar.addWidget(self.btn_nav_instalar, alignment=Qt.AlignCenter)
        ly_sidebar.addWidget(self.btn_nav_gestionar, alignment=Qt.AlignCenter)
        ly_sidebar.addStretch()

        # --- CONTENIDO (STACKED WIDGET) ---
        self.stack = QStackedWidget()
        self.vista_instalacion = QWidget()
        self.setup_view_instalar()
        self.vista_gestor = QWidget()
        self.setup_view_gestionar()

        self.stack.addWidget(self.vista_instalacion)
        self.stack.addWidget(self.vista_gestor)

        self.layout_principal.addWidget(self.sidebar)
        self.layout_principal.addWidget(self.stack)

    def setup_view_instalar(self):
        """Vista principal de Drag & Drop e instalaci√≥n"""
        layout = QVBoxLayout(self.vista_instalacion)
        layout.setContentsMargins(40, 20, 40, 40)
        layout.setSpacing(15)

        # Bot√≥n Volver
        self.btn_volver = QPushButton("‚úï")
        self.btn_volver.setObjectName("btn_volver")
        self.btn_volver.setFixedSize(35, 35)
        self.btn_volver.clicked.connect(self.estado_inicial)
        self.btn_volver.setCursor(Qt.PointingHandCursor)
        self.btn_volver.hide()
        
        lt = QHBoxLayout(); lt.addStretch(); lt.addWidget(self.btn_volver)
        layout.addLayout(lt)
        layout.addStretch()

        # Contenedor Icono
        self.contenedor_icono = QWidget()
        self.contenedor_icono.setObjectName("contenedor_icono")
        self.contenedor_icono.setFixedSize(180, 180)
        ly_ico = QVBoxLayout(self.contenedor_icono)
        self.label_icono = QLabel()
        self.label_icono.setObjectName("label_logo_principal")
        self.label_icono.setAlignment(Qt.AlignCenter)
        self.set_main_logo("+")
        ly_ico.addWidget(self.label_icono)
        layout.addWidget(self.contenedor_icono, alignment=Qt.AlignCenter)

        # Etiquetas de Texto
        self.label_nombre = QLabel(self.lang.get("welcome_msg", "Welcome"))
        self.label_nombre.setObjectName("label_nombre")
        self.label_nombre.setAlignment(Qt.AlignCenter)
        layout.addWidget(self.label_nombre) 

        self.label_version = QLabel(self.lang.get("drag_drop_info", "Drag and drop a file"))
        self.label_version.setObjectName("label_version")
        self.label_version.setAlignment(Qt.AlignCenter)
        layout.addWidget(self.label_version) 

        # Barra de progreso
        self.barra_progreso = QProgressBar()
        self.barra_progreso.setObjectName("barra_progreso")
        self.barra_progreso.setFixedHeight(6)
        self.barra_progreso.setFixedWidth(300)
        self.barra_progreso.setTextVisible(False)
        self.barra_progreso.hide()
        layout.addWidget(self.barra_progreso, alignment=Qt.AlignCenter)

        # Botones de Acci√≥n
        self.btn_abrir = QPushButton(self.lang.get("btn_select", "Select File"))
        self.btn_abrir.setObjectName("btn_abrir")
        self.btn_abrir.setFixedSize(220, 48)
        self.btn_abrir.clicked.connect(self.seleccionar_archivo)
        layout.addWidget(self.btn_abrir, alignment=Qt.AlignCenter)

        self.btn_instalar = QPushButton(self.lang.get("btn_install", "Install Now"))
        self.btn_instalar.setObjectName("btn_instalar")
        self.btn_instalar.setFixedSize(220, 48)
        self.btn_instalar.clicked.connect(self.iniciar_instalacion)
        self.btn_instalar.hide()
        layout.addWidget(self.btn_instalar, alignment=Qt.AlignCenter)

        layout.addStretch()

    def setup_view_gestionar(self):
        """Vista del gestor de aplicaciones instaladas"""
        layout = QVBoxLayout(self.vista_gestor)
        layout.setContentsMargins(35, 35, 35, 35)
        layout.setSpacing(20)
        
        lbl_t = QLabel(self.lang.get("title_gestor", "Installed Apps"))
        lbl_t.setObjectName("titulo_gestor")
        layout.addWidget(lbl_t)

        self.txt_busqueda = QLineEdit()
        self.txt_busqueda.setPlaceholderText(self.lang.get("search_placeholder", "Search..."))
        self.txt_busqueda.setObjectName("barra_busqueda")
        self.txt_busqueda.setFixedHeight(45)
        self.txt_busqueda.textChanged.connect(self.filtrar_aplicaciones)
        layout.addWidget(self.txt_busqueda)

        self.scroll = QScrollArea()
        self.scroll.setWidgetResizable(True)
        self.scroll.setObjectName("scroll_area")
        self.contenedor_lista = QWidget()
        self.lista_layout = QVBoxLayout(self.contenedor_lista)
        self.lista_layout.setAlignment(Qt.AlignTop)
        self.lista_layout.setSpacing(10)
        self.scroll.setWidget(self.contenedor_lista)
        layout.addWidget(self.scroll)

    def cambiar_vista(self, index):
        """Cambia entre pesta√±as y refresca la sidebar"""
        self.stack.setCurrentIndex(index)
        self.btn_nav_instalar.setProperty("active", index == 0)
        self.btn_nav_gestionar.setProperty("active", index == 1)
        
        for btn in [self.btn_nav_instalar, self.btn_nav_gestionar]:
            btn.style().unpolish(btn)
            btn.style().polish(btn)
            
        if index == 1:
            self.cargar_lista_apps()

    def estado_inicial(self):
        """Reset total a la pantalla de bienvenida"""
        self.ruta_archivo = ""; self.manager_actual = None
        self.btn_abrir.show(); self.btn_instalar.hide(); self.btn_volver.hide()
        self.label_nombre.setText(self.lang.get("welcome_msg", "Welcome"))
        self.label_version.setText(self.lang.get("drag_drop_info", "Drag and drop a file"))
        self.set_main_logo("+")
        self.barra_progreso.hide(); self.barra_progreso.setValue(0)
        self.btn_instalar.setStyleSheet("") 

    def preparar_archivo(self, archivo):
        """Detecta el motor adecuado y verifica soporte del sistema"""
        self.ruta_archivo = archivo
        ext = archivo.lower()
        
        motores = {
            ".deb": (self.mgr_deb, "deb"),
            ".appimage": (self.mgr_appimage, "appimage"),
            ".flatpak": (self.mgr_flatpak, "flatpak"),
            ".flatpakref": (self.mgr_flatpak, "flatpak"),
            ".snap": (self.mgr_snap, "snap")
        }

        # Identificamos motor
        self.manager_actual = None
        motor_nombre = ""
        for k, v in motores.items():
            if ext.endswith(k):
                self.manager_actual, motor_nombre = v
                break
        
        if not self.manager_actual: return

        # Verificaci√≥n de Soporte (Flatpak/Snap)
        if not SystemChecker.esta_instalado(motor_nombre):
            self.preparar_ui_soporte_faltante(motor_nombre)
            return

        # Flujo Normal: Extraer datos y mostrar UI de instalaci√≥n
        ya_existe = self.manager_actual.esta_instalado(archivo)
        nombre, info_texto = self.manager_actual.obtener_datos(archivo)

        self.btn_abrir.hide()
        self.btn_instalar.show()
        self.btn_instalar.setEnabled(True)
        self.btn_volver.show()
        self.label_nombre.setText(nombre)
        self.set_main_logo("üì¶")
        
        # UI seg√∫n si ya existe o no
        if ya_existe:
            self.btn_instalar.setText(self.lang.get("btn_reinstall", "Reinstall"))
            self.btn_instalar.setStyleSheet("background-color: #f39c12; color: white;")
            msg_suffix = self.lang.get("already_installed", "(Already installed)")
            self.label_version.setText(f"{info_texto} {msg_suffix}")
        else:
            self.btn_instalar.setText(self.lang.get("btn_install", "Install Now"))
            self.btn_instalar.setStyleSheet("") 
            self.label_version.setText(info_texto)

        # Buscar icono en segundo plano
        threading.Thread(target=self.manager_actual.buscar_icono, args=(archivo,), daemon=True).start()

    def preparar_ui_soporte_faltante(self, motor):
        """Ofrece instalar el motor (Flatpak/Snap) si no existe"""
        txt_not_detected = self.lang.get("support_not_detected", "Support not detected")
        txt_needs = self.lang.get("system_needs", "Your system needs")
        
        self.label_nombre.setText(f"{motor.capitalize()} {txt_not_detected}")
        self.label_version.setText(f"{txt_needs} {motor}.")
        self.set_main_logo("‚ö†Ô∏è")
        
        self.btn_abrir.hide()
        self.btn_instalar.show()
        self.btn_instalar.setText(f"{self.lang.get('btn_activate', 'Activate')} {motor.capitalize()}")
        self.btn_instalar.setStyleSheet("background-color: #27ae60; color: white; font-weight: bold;")
        
        try: self.btn_instalar.clicked.disconnect()
        except: pass
        self.btn_instalar.clicked.connect(lambda: self.activar_soporte_sistema(motor))
        self.btn_volver.show()

    def activar_soporte_sistema(self, motor):
        """L√≥gica para instalar motores faltantes v√≠a pkexec"""
        comando = ""
        if motor == "flatpak":
            comando = "pkexec apt-get update && pkexec apt-get install -y flatpak"
        elif motor == "snap":
            comando = "pkexec apt-get update && pkexec apt-get install -y snapd"
            
        if comando:
            self.btn_instalar.setEnabled(False)
            self.label_version.setText(self.lang.get("msg_activating", "Activating support... please wait."))
            
            def tarea():
                res = subprocess.run(comando, shell=True)
                # Al terminar, refrescamos la UI
                QTimer.singleShot(0, lambda: self.preparar_archivo(self.ruta_archivo))

            threading.Thread(target=tarea, daemon=True).start()

    def iniciar_instalacion(self):
        """Lanza el proceso de instalaci√≥n o cancela si ya est√° en curso"""
        if not self.instalando:
            self.instalando = True
            self.barra_progreso.show()
            self.barra_progreso.setValue(0)
            self.btn_instalar.setText(self.lang.get("btn_cancel", "Cancel Installation"))
            self.btn_instalar.setStyleSheet("background-color: #e74c3c; color: white;") 
            
            threading.Thread(target=self.manager_actual.instalar, args=(self.ruta_archivo,), daemon=True).start()
        else:
            self.manager_actual.cancelar_operacion()
            self.estado_inicial()

    def mostrar_resultado(self, exito, mensaje_key):
        """Muestra el popup final y resetea la UI"""
        self.barra_progreso.setValue(100 if exito else 0)
        texto_mensaje = self.lang.get(mensaje_key, mensaje_key)
        QMessageBox.information(self, "SuperInstall", texto_mensaje)
        self.estado_inicial()

    # --- UTILIDADES DE UI ---

    def set_main_logo(self, fallback_emoji):
        ruta_logo = os.path.join("assets", "icons", "logo_bellota.png")
        if os.path.exists(ruta_logo):
            pix = QPixmap(ruta_logo)
            self.label_icono.setPixmap(pix.scaled(150, 150, Qt.KeepAspectRatio, Qt.SmoothTransformation))
            self.label_icono.setText("")
        else:
            self.label_icono.setPixmap(QPixmap())
            self.label_icono.setText(fallback_emoji)
            self.label_icono.setStyleSheet("font-size: 90px;")

    def actualizar_icono_visual(self, ruta):
        if ruta and os.path.exists(ruta):
            self.label_icono.setText("")
            self.label_icono.setPixmap(QPixmap(ruta).scaled(180, 180, Qt.KeepAspectRatio, Qt.SmoothTransformation))

    def actualizar_progreso(self, v):
        self.barra_progreso.setValue(v)

    def cargar_estilos(self):
        ruta = os.path.join("assets", "styles", "style.qss")
        if os.path.exists(ruta):
            with open(ruta, "r") as f:
                self.setStyleSheet(f.read())

    # --- GESTOR DE APPS INSTALADAS ---

    def cargar_lista_apps(self):
        # Limpiar lista actual
        while self.lista_layout.count():
            item = self.lista_layout.takeAt(0)
            widget = item.widget()
            if widget: widget.deleteLater()

        # Cargar de sistema y Managers
        self.cargar_apps_desktop()
        for mgr, tipo in [(self.mgr_flatpak, "flatpak"), (self.mgr_snap, "snap")]:
            try:
                for app in mgr.listar_instalados():
                    self.lista_layout.addWidget(WidgetAppInstalada(app['nombre'], app['id'], app['icono'], self.confirmar_borrado, self.lang, tipo))
            except: pass

    def cargar_apps_desktop(self):
        rutas = [os.path.expanduser("~/.local/share/applications/"), "/usr/share/applications/"]
        for r in rutas:
            if os.path.exists(r):
                for f in sorted(os.listdir(r)):
                    if f.endswith(".desktop"):
                        self.procesar_archivo_desktop(os.path.join(r, f))

    def procesar_archivo_desktop(self, path):
        nombre, icono = "App", "system-run"
        try:
            with open(path, 'r', errors='ignore') as file:
                en_seccion = False
                for l in file:
                    l = l.strip()
                    if l == "[Desktop Entry]": en_seccion = True
                    elif en_seccion and l.startswith("["): break
                    if en_seccion:
                        if l.startswith("Name="): nombre = l.split('=', 1)[1].strip()
                        elif l.startswith("Icon="): icono = self.resolver_ruta_icono(l.split('=', 1)[1].strip())
        except: pass

        if nombre != "App":
            tipo = "appimage" if "/home/" in path else "system"
            self.lista_layout.addWidget(WidgetAppInstalada(nombre, path, icono, self.confirmar_borrado, self.lang, tipo))

    def filtrar_aplicaciones(self, texto):
        texto = texto.lower()
        for i in range(self.lista_layout.count()):
            widget = self.lista_layout.itemAt(i).widget()
            if widget:
                widget.setVisible(texto in widget.lbl_nombre.text().lower())

    def confirmar_borrado(self, nombre, ruta_o_id, tipo_app):
        # Traducci√≥n del di√°logo de borrado
        msg = f"{self.lang.get('msg_confirm_delete', 'Delete')} {nombre}?"
        if QMessageBox.question(self, self.lang.get("title_delete", "Delete"), msg) == QMessageBox.Yes:
            exito = False
            if tipo_app == "flatpak": exito = self.mgr_flatpak.desinstalar(ruta_o_id)
            elif tipo_app == "snap": exito = self.mgr_snap.desinstalar(ruta_o_id)
            elif tipo_app == "appimage": exito = self.mgr_appimage.desinstalar(ruta_o_id)
            else: exito = self.mgr_deb.desinstalar(ruta_o_id)
            if exito: QTimer.singleShot(500, self.cargar_lista_apps)

    def resolver_ruta_icono(self, nombre_icono):
        if os.path.isabs(nombre_icono) and os.path.exists(nombre_icono): return nombre_icono
        rutas_sistema = ["/usr/share/pixmaps", "/usr/share/icons/hicolor/scalable/apps", "/usr/share/icons/hicolor/48x48/apps", "/usr/share/icons/hicolor/128x128/apps", os.path.expanduser("~/.local/share/icons")]
        for ruta in rutas_sistema:
            for ext in [".png", ".svg", ".xpm"]:
                posible = os.path.join(ruta, f"{nombre_icono}{ext}")
                if os.path.exists(posible): return posible
        return nombre_icono

    # --- EVENTOS DRAG & DROP ---
    def dragEnterEvent(self, event):
        if event.mimeData().hasUrls():
            event.accept()
            self.contenedor_icono.setStyleSheet("background-color: rgba(72, 126, 176, 0.15); border: 3px solid #487eb0; border-radius: 20px;")

    def dragLeaveEvent(self, event):
        self.contenedor_icono.setStyleSheet("")

    def dropEvent(self, event):
        self.contenedor_icono.setStyleSheet("")
        self.cambiar_vista(0)
        archivo = event.mimeData().urls()[0].toLocalFile()
        self.preparar_archivo(archivo)

    def seleccionar_archivo(self):
        filtro = "Apps (*.deb *.AppImage *.flatpak *.flatpakref *.snap)"
        archivo, _ = QFileDialog.getOpenFileName(self, self.lang.get("btn_select", "Open"), "", filtro)
        if archivo: self.preparar_archivo(archivo)

================================================
RESUMEN DE ARCHIVOS PROCESADOS:
================================================
./core/config.py
./core/constants.py
./core/managers/base.py
./core/managers/deb.py
./core/managers/appimage.py
./core/managers/flatpak.py
./core/managers/snap.py
./assets/styles/style.qss
./assets/locales/es.json
./assets/locales/en.json
./main.py
./utils/signals.py
./utils/system_check.py
./utils/helpers.py
./gui/widgets.py
./gui/main_window.py
